#!/usr/bin/env bash
# =============================================================================
# GroqBash â€” Bash-first wrapper for the Groq API
# File: groqbash
# Copyright (C) 2026 Cristian Evangelisti
# License: GPL-3.0-or-later
# Source: https://github.com/kamaludu/groqbash
# =============================================================================
# Bash-only. Requires: bash, jq, curl, mktemp, stat or find.
# Designed for POSIX-like environments (Linux, macOS, BSD, WSL, Termux) with required tools installed.
set -euo pipefail

# PRE-CORE (COSTANTI + HELPER MINIMI)
SCRIPT_NAME="groqbash"
SCRIPT_VERSION="2.0.0"
SCRIPT_DATE="2026-02-02"

GROQBASH_ERR_NO_API_KEY=10
GROQBASH_ERR_BAD_MODEL=11
GROQBASH_ERR_CURL_FAILED=12
GROQBASH_ERR_INVALID_JSON=13
GROQBASH_ERR_NO_PROMPT=14
GROQBASH_ERR_TMP=15
GROQBASH_ERR_API=16

GROQBASHERRNOAPIKEY=$GROQBASH_ERR_NO_API_KEY
GROQBASHERRBAD_MODEL=$GROQBASH_ERR_BAD_MODEL
GROQBASHERRCURL_FAILED=$GROQBASH_ERR_CURL_FAILED
GROQBASHERRINVALID_JSON=$GROQBASH_ERR_INVALID_JSON
GROQBASHERRNO_PROMPT=$GROQBASH_ERR_NO_PROMPT
GROQBASHERRTMP=$GROQBASH_ERR_TMP
GROQBASHERRAPI=$GROQBASH_ERR_API

if ! command -v jq >/dev/null 2>&1; then
  printf 'Error: jq is required. Please install jq and retry.\n' >&2
  exit "$GROQBASHERRINVALID_JSON"
fi

# Forward declaration to avoid early calls before full definition
refresh_models_dispatch() { :; }

resolve_script_dir() {
  local src="$0" rl dir
  if command -v readlink >/dev/null 2>&1 && [ -L "$src" ]; then
    rl="$(readlink "$src" 2>/dev/null || true)"
    [ -n "$rl" ] && case "$rl" in /*) src="$rl" ;; *) src="$(dirname "$src")/$rl" ;; esac
  fi
  dir="$(cd "$(dirname "$src")" >/dev/null 2>&1 && pwd || printf '%s' "$(dirname "$src")")"
  printf '%s' "$dir"
}

SCRIPTDIR="$(resolve_script_dir)"
GROQBASH_DIR="${GROQBASH_DIR:-$SCRIPTDIR/groqbash.d}"
GROQBASH_CONFIG_DIR="${GROQBASH_CONFIG_DIR:-$GROQBASH_DIR/config}"
GROQBASH_MODELS_DIR="${GROQBASH_MODELS_DIR:-$GROQBASH_DIR/models}"
GROQBASH_TEMPLATES_DIR="${GROQBASH_TEMPLATES_DIR:-$GROQBASH_DIR/templates}"
GROQBASH_HISTORY_DIR="${GROQBASH_HISTORY_DIR:-$GROQBASH_DIR/history}"
GROQBASH_TMPDIR="${GROQBASH_TMPDIR:-$GROQBASH_DIR/tmp}"
GROQBASH_EXTRAS_DIR="${GROQBASH_EXTRAS_DIR:-$GROQBASH_DIR/extras}"
MODELS_FILE="${MODELS_FILE:-$GROQBASH_MODELS_DIR/models.txt}"

umask 077
mkdir -p "$GROQBASH_CONFIG_DIR" "$GROQBASH_MODELS_DIR" "$GROQBASH_TEMPLATES_DIR" "$GROQBASH_HISTORY_DIR" "$GROQBASH_TMPDIR" "$GROQBASH_EXTRAS_DIR/providers" 2>/dev/null || true
chmod 700 "$GROQBASH_DIR" 2>/dev/null || true

CONTENT=""
RUN_TMPDIR=""
PAYLOAD=""
RESP=""
ERRF=""
JSON_INPUT=""
ARGS=()
FILE_INPUTS=()
TEMPLATE=""
BATCH_FILE=""
CHAT_MODE=0
SET_DEFAULT_MODEL=""
REFRESH_MODELS=0
LIST_MODELS=0
FORCE_SAVE_MODE=""
OUT_PATH=""
SYSTEM_PROMPT="${SYSTEM_PROMPT:-}"
TURE="${TURE:-1.0}"
MAX_TOKENS="${MAX_TOKENS:-4096}"
MODEL="${MODEL:-}"
AUTO_POLICY="${AUTO_POLICY:-preferred}"
DEBUG=0
QUIET=0
DRY_RUN=0
STREAM_MODE=""
OUTPUT_MODE="text"
THRESHOLD="${THRESHOLD:-1000}"
MAX_RETRIES="${MAX_RETRIES:-3}"
SUPPORTED_PROVIDERS="groq gemini huggingface"
PROVIDER="groq"
PROVIDER_CLI=""
PROVIDER_INTERACTIVE=0
INSTALL_EXTRAS=0
ALLOWED_MODELS=""

CURL_BASE_OPTS=( --silent --show-error --no-buffer --max-time 120 )

dbg() {
  [ "${DEBUG:-0}" -eq 1 ] || return 0
  local msg="$*"
  printf '%s\n' "$msg" >&2
}
is_tty_out() { [ -t 1 ]; }

_get_perm_string() {
  local path="$1" perm=""
  case "$(uname 2>/dev/null || echo Linux)" in
    Darwin)
      perm="$(stat -f %Sp "$path" 2>/dev/null || true)"
      ;;
    *)
      if command -v stat >/dev/null 2>&1; then
        perm="$(stat -c %A "$path" 2>/dev/null || true)"
      elif command -v find >/dev/null 2>&1; then
        perm="$(find "$path" -maxdepth 0 -printf '%M' 2>/dev/null || true)"
      fi
      ;;
  esac
  printf '%s' "$perm"
}
_get_owner() {
  local path="$1" owner=""
  case "$(uname 2>/dev/null || echo Linux)" in
    Darwin)
      owner="$(stat -f %Su "$path" 2>/dev/null || true)"
      ;;
    *)
      if command -v stat >/dev/null 2>&1; then
        owner="$(stat -c %U "$path" 2>/dev/null || true)"
      elif command -v find >/dev/null 2>&1; then
        owner="$(find "$path" -maxdepth 0 -printf '%u' 2>/dev/null || true)"
      fi
      ;;
  esac
  printf '%s' "$owner"
}
_get_file_signature() {
  local path="$1" sig=""
  case "$(uname 2>/dev/null || echo Linux)" in
    Darwin)
      sig="$(stat -f '%Sp|%Su|%Sg|%z|%m' "$path" 2>/dev/null || true)"
      ;;
    *)
      if command -v stat >/dev/null 2>&1; then
        sig="$(stat -c '%A|%U|%G|%s|%Y' "$path" 2>/dev/null || true)"
      elif command -v find >/dev/null 2>&1; then
        sig="$(find "$path" -maxdepth 0 -printf '%M|%u|%g|%s|%T@' 2>/dev/null || true)"
      fi
      ;;
  esac
  printf '%s' "$sig"
}
getfile_signature() { _get_file_signature "$1"; }
_is_world_writable() {
  local d="$1" perms others_write
  [ -d "$d" ] || return "$GROQBASHERRTMP"
  perms="$(_get_perm_string "$d")"
  [ -z "$perms" ] && return "$GROQBASHERRTMP"
  others_write="$(printf '%s' "$perms" | awk '{print substr($0,9,1)}')"
  [ "$others_write" = "w" ]
}

make_tmpdir() {
  umask 077
  if [ -n "${GROQBASH_TMPDIR:-}" ] && [ -d "$GROQBASH_TMPDIR" ]; then
    local tmpd
    tmpd="$(mktemp -d -p "$GROQBASH_TMPDIR" groq.XXXX 2>/dev/null || true)"
    if [ -n "$tmpd" ] && [ -d "$tmpd" ]; then
      chmod 700 "$tmpd" 2>/dev/null || true
      printf '%s' "$tmpd"
      return 0
    fi
  fi
  return "$GROQBASHERRTMP"
}

ensure_run_tmpdir() {
  if [ -n "${RUN_TMPDIR:-}" ] && [ -d "${RUN_TMPDIR:-}" ]; then return 0; fi
  RUN_TMPDIR="$(make_tmpdir)" || { printf 'Error: cannot create RUN_TMPDIR in %s\n' "$GROQBASH_TMPDIR" >&2; exit "$GROQBASHERRTMP"; }
  PAYLOAD="$RUN_TMPDIR/payload.json"
  RESP="$RUN_TMPDIR/resp.json"
  ERRF="$RUN_TMPDIR/err.log"
  trap 'rm -rf "$RUN_TMPDIR"' EXIT INT TERM
  dbg "Created RUN_TMPDIR: $RUN_TMPDIR"
}

file_readable() { [ -r "$1" ] && [ -f "$1" ]; }
trim() { printf '%s' "$1" | awk '{$1=$1; print}'; }
is_number() { printf '%s\n' "$1" | awk 'BEGIN{exit 0} {exit !( $0+0 == $0+0 )}'; }

load_local_config() {
  local cfg="$GROQBASH_CONFIG_DIR/config" key val
  [ -f "$cfg" ] || return 0
  while IFS= read -r line || [ -n "$line" ]; do
    case "$line" in ''|\#*) continue ;; esac
    key="$(printf '%s' "$line" | awk -F= '{print $1}')"
    val="${line#*=}"
    case "$key" in
      MODEL) [ -n "$val" ] && MODEL="$val" ;;
      TEMPERATURE|TURE) [ -n "$val" ] && TURE="$val" ;;
      MAX_TOKENS) [ -n "$val" ] && MAX_TOKENS="$val" ;;
      FORMAT) [ -n "$val" ] && OUTPUT_MODE="$val" ;;
      THRESHOLD) [ -n "$val" ] && THRESHOLD="$val" ;;
    esac
  done < "$cfg"
}
load_whitelist() {
  ALLOWED_MODELS=""
  if [ -f "$MODELS_FILE" ] && [ -s "$MODELS_FILE" ]; then
    ALLOWED_MODELS="$(cat "$MODELS_FILE" 2>/dev/null || true)"
  fi
}

###############################################################################
##### BEGIN PROVIDER DEFAULT (embedded) #######################################
###############################################################################
# Provider: groq (embedded)
GROQ_API_KEY="${GROQ_API_KEY:-}"

# shellcheck disable=SC2329
_get_work_tmpdir() {
  if [ -n "${RUN_TMPDIR:-}" ] && [ -d "${RUN_TMPDIR:-}" ]; then
    printf '%s' "$RUN_TMPDIR"
    return 0
  fi
  if [ -n "${GROQBASH_TMPDIR:-}" ] && [ -d "$GROQBASH_TMPDIR" ]; then
    printf '%s' "$GROQBASH_TMPDIR"
    return 0
  fi
  if type make_tmpdir >/dev/null 2>&1; then
    local d
    d="$(make_tmpdir 2>/dev/null || true)"
    if [ -n "$d" ] && [ -d "$d" ]; then
      printf '%s' "$d"
      return 0
    fi
  fi
  return "$GROQBASHERRTMP"
}

# shellcheck disable=SC2329
_mktemp_in_dir() {
  local dir="$1" tmpf
  [ -z "$dir" ] && return "$GROQBASHERRTMP"
  [ ! -d "$dir" ] && return "$GROQBASHERRTMP"
  tmpf="$(mktemp -p "$dir" groq-XXXX 2>/dev/null || true)"
  [ -z "$tmpf" ] && return "$GROQBASHERRTMP"
  printf '%s' "$tmpf"
  return 0
}

# shellcheck disable=SC2329
buildpayloadgroq() {
  local workdir tmp_payload model_in_file model_to_use user_prompt
  workdir="$(_get_work_tmpdir)" || return "$GROQBASHERRTMP"
  tmp_payload="$(_mktemp_in_dir "$workdir")" || return "$GROQBASHERRTMP"
  umask 077

  if [ -n "${JSON_INPUT:-}" ]; then
    if jq -e 'has("messages")' "$JSON_INPUT" >/dev/null 2>&1; then
      cp "$JSON_INPUT" "$tmp_payload" 2>/dev/null || { rm -f "$tmp_payload" 2>/dev/null || true; return "$GROQBASHERRTMP"; }
      mv "$tmp_payload" "$PAYLOAD" 2>/dev/null || cp -f "$tmp_payload" "$PAYLOAD" 2>/dev/null || true
      chmod 600 "$PAYLOAD" 2>/dev/null || true
      return 0
    fi
    if jq -e 'has("prompt")' "$JSON_INPUT" >/dev/null 2>&1; then
      user_prompt="$(jq -r '.prompt' "$JSON_INPUT" 2>/dev/null || true)"
      model_in_file="$(jq -r '.model // empty' "$JSON_INPUT" 2>/dev/null || true)"
      model_to_use="${model_in_file:-$MODEL}"
      jq -n --arg model "$model_to_use" \
            --argjson stream "$( [ "${STREAM_MODE:-}" = "true" ] && printf 'true' || printf 'false' )" \
            --arg ture "$TURE" \
            --arg max_tokens "$MAX_TOKENS" \
            --arg user "$user_prompt" \
            '{model:$model, stream:$stream, temperature:($ture|tonumber), max_tokens:($max_tokens|tonumber), messages:[{role:"user",content:$user}] }' >"$tmp_payload"
      mv "$tmp_payload" "$PAYLOAD" 2>/dev/null || cp -f "$tmp_payload" "$PAYLOAD" 2>/dev/null || true
      chmod 600 "$PAYLOAD" 2>/dev/null || true
      return 0
    fi
    cp "$JSON_INPUT" "$tmp_payload" 2>/dev/null || { rm -f "$tmp_payload" 2>/dev/null || true; return "$GROQBASHERRTMP"; }
    mv "$tmp_payload" "$PAYLOAD" 2>/dev/null || cp -f "$tmp_payload" "$PAYLOAD" 2>/dev/null || true
    chmod 600 "$PAYLOAD" 2>/dev/null || true
    return 0
  fi

  if [ -n "${SYSTEM_PROMPT:-}" ]; then
    jq -n --arg model "$MODEL" \
          --argjson stream "$( [ "${STREAM_MODE:-}" = "true" ] && printf 'true' || printf 'false' )" \
          --arg ture "$TURE" \
          --arg max_tokens "$MAX_TOKENS" \
          --arg system "$SYSTEM_PROMPT" \
          --arg user "$CONTENT" \
          '{model:$model, stream:$stream, temperature:($ture|tonumber), max_tokens:($max_tokens|tonumber), messages:[{role:"system",content:$system},{role:"user",content:$user}] }' >"$tmp_payload"
  else
    jq -n --arg model "$MODEL" \
          --argjson stream "$( [ "${STREAM_MODE:-}" = "true" ] && printf 'true' || printf 'false' )" \
          --arg ture "$TURE" \
          --arg max_tokens "$MAX_TOKENS" \
          --arg user "$CONTENT" \
          '{model:$model, stream:$stream, temperature:($ture|tonumber), max_tokens:($max_tokens|tonumber), messages:[{role:"user",content:$user}] }' >"$tmp_payload"
  fi
  mv "$tmp_payload" "$PAYLOAD" 2>/dev/null || cp -f "$tmp_payload" "$PAYLOAD" 2>/dev/null || true
  chmod 600 "$PAYLOAD" 2>/dev/null || true
  return 0
}

# shellcheck disable=SC2329
callapigroq() {
  if [ -z "${GROQ_API_KEY:-}" ]; then printf 'Error: GROQ_API_KEY is not set.\n' >&2; return "$GROQBASHERRNOAPIKEY"; fi
  if [ ! -s "${PAYLOAD:-}" ]; then printf 'Error: payload file missing or empty: %s\n' "${PAYLOAD:-<unset>}" >&2; return "$GROQBASHERRTMP"; fi
  if [ "${DRY_RUN:-0}" -eq 1 ]; then printf 'DRY-RUN: skipping HTTP call (exit 0)\n' >&2; return 0; fi

  local workdir tmpout http_code _time_total api_url
  workdir="$(_get_work_tmpdir)" || return "$GROQBASHERRTMP"
  tmpout="$(_mktemp_in_dir "$workdir")" || return "$GROQBASHERRTMP"
  api_url="https://api.groq.com/openai/v1/chat/completions"
  curl "${CURL_BASE_OPTS[@]}" -H "Authorization: Bearer $GROQ_API_KEY" -H "Content-Type: application/json" --data-binary @"$PAYLOAD" -o "$RESP" -w '%{http_code} %{time_total}' "$api_url" 2>"$ERRF" >"$tmpout" || true
  read -r http_code _time_total < "$tmpout" 2>/dev/null || { http_code="$(cat "$tmpout" 2>/dev/null || echo "000")"; }
  rm -f "$tmpout" 2>/dev/null || true
  case "$http_code" in 2*) return 0 ;; *) dbg "HTTP error code: $http_code"; dbg "Response (head):"; head -n 200 "$RESP" >&2 || true; dbg "Curl stderr (head):"; head -n 200 "$ERRF" >&2 || true; return "$GROQBASHERRAPI" ;; esac
}

# shellcheck disable=SC2329
callapistreaming_groq() {
  if [ -z "${GROQ_API_KEY:-}" ]; then printf 'Error: GROQ_API_KEY is not set.\n' >&2; return "$GROQBASHERRNOAPIKEY"; fi
  if [ "${DRY_RUN:-0}" -eq 1 ]; then printf 'DRY-RUN: skipping streaming HTTP call (exit 0)\n' >&2; return 0; fi

  local api_url rc
  api_url="https://api.groq.com/openai/v1/chat/completions"
  curl "${CURL_BASE_OPTS[@]}" -H "Authorization: Bearer $GROQ_API_KEY" -H "Content-Type: application/json" --data-binary @"$PAYLOAD" "$api_url" 2>"$ERRF" | tee "$RESP" | \
  while IFS= read -r line; do
    case "$line" in
      'data: [DONE]'|'data:[DONE]') break ;;
      data:\ * )
        json="${line#data: }"
        raw="$(printf '%s' "$json" | jq -R -c 'fromjson? | (.choices[]?.delta?.content // .choices[]?.message?.content // empty) | select(length>0)' 2>>"$ERRF" || true)"
        if [ -n "$raw" ]; then
          printf '%s' "$raw"
        fi
        ;;
      *) ;;
    esac
  done
  rc=${PIPESTATUS[0]:-0}
  [ "$rc" -ne 0 ] && { dbg "curl stderr (head):"; head -n 50 "$ERRF" >&2 || true; return "$GROQBASHERRCURL_FAILED"; }
  return 0
}

# shellcheck disable=SC2329
refreshmodelsgroq() {
  if [ -z "${GROQ_API_KEY:-}" ]; then printf 'Error: GROQ_API_KEY is required to refresh models.\n' >&2; return "$GROQBASHERRNOAPIKEY"; fi
  local workdir tmpd out errf parsed tmpout api_url jq_ok
  workdir="$(_get_work_tmpdir)" || return "$GROQBASHERRTMP"
  tmpd="$(mktemp -d -p "$workdir" groq-models.XXXX 2>/dev/null || true)"
  [ -z "$tmpd" ] && return "$GROQBASHERRTMP"
  out="$tmpd/models.json"; errf="$tmpd/curl.err"
  api_url="https://api.groq.com/openai/v1/models"
  if ! curl "${CURL_BASE_OPTS[@]}" -H "Authorization: Bearer $GROQ_API_KEY" -H "Content-Type: application/json" "$api_url" -o "$out" 2>"$errf"; then
    dbg "curl stderr:"; head -n 50 "$errf" >&2 || true
    rm -rf "$tmpd"
    return "$GROQBASHERRCURL_FAILED"
  fi
  parsed="$tmpd/parsed_models.txt"
  if jq -e . "$out" >/dev/null 2>&1; then
    jq_ok=1
    jq -r '.data[]?.id // empty' "$out" | sort -u > "$parsed" || true
  else
    jq_ok=0
    printf 'Warning: models response not valid JSON; using heuristic parse\n' >&2
    grep -oE '"id"[[:space:]]*:[[:space:]]*"[^"]+"' "$out" 2>/dev/null | sed -E 's/.*"([^"]+)".*/\1/' | sort -u > "$parsed" || true
  fi
  if [ -s "$parsed" ]; then
    if [ "$jq_ok" -eq 0 ]; then
      if ! awk 'NF{exit 0} END{exit 1}' "$parsed"; then
        dbg "Heuristic parse produced no models; aborting refresh."
        rm -rf "$tmpd"
        return "$GROQBASHERRAPI"
      fi
      # Validate model id format before writing
      if ! awk '/^[[:alnum:]._:-]+$/{print; ok=1} END{exit !ok}' "$parsed"; then
        printf 'Heuristic parse produced invalid model ids; aborting refresh\n' >&2
        rm -rf "$tmpd"
        return "$GROQBASHERRAPI"
      fi
    fi
    mkdir -p "$(dirname "$MODELS_FILE")" 2>/dev/null || true
    tmpout="$(_mktemp_in_dir "$(dirname "$MODELS_FILE")" )" || tmpout="$MODELS_FILE.tmp"
    cat "$parsed" > "$tmpout"
    mv "$tmpout" "$MODELS_FILE" 2>/dev/null || cp -f "$tmpout" "$MODELS_FILE" 2>/dev/null || true
    chmod 600 "$MODELS_FILE" 2>/dev/null || true
    rm -rf "$tmpd"
    return 0
  else
    dbg "Raw response (head):"; head -n 50 "$out" >&2 || true
    rm -rf "$tmpd"
    return "$GROQBASHERRAPI"
  fi
}

# shellcheck disable=SC2329
validatemodelgroq() {
  local model="$1"
  if [ -f "$MODELS_FILE" ] && [ -s "$MODELS_FILE" ]; then
    grep -x -F -q "$model" "$MODELS_FILE" 2>/dev/null
    return $?
  fi
  return 0
}

# shellcheck disable=SC2329
autoselectmodelgroq() {
  local file="$MODELS_FILE" result=""
  if [ -f "$file" ] && [ -s "$file" ]; then
    if jq -e . "$file" >/dev/null 2>&1; then
      result="$(jq -r '.data[]?.id // empty' "$file" 2>/dev/null | awk 'NF{print; exit}')"
    else
      result="$(awk 'NF{print; exit}' "$file" 2>/dev/null || true)"
    fi
  fi
  result="$(printf '%s' "$result" | awk '{$1=$1;print}')"
  printf '%s' "$result"
  return 0
}
###############################################################################
##### END PROVIDER DEFAULT (embedded) #########################################
###############################################################################

# CORE RUNTIME
call_provider() {
  local fn="$1" shift_args=("${@:2}")
  if type "$fn" >/dev/null 2>&1; then "$fn" "${shift_args[@]}"; return $?; fi
  return 127
}

build_payload_from_vars() {
  ensure_run_tmpdir
  local fn="buildpayload${PROVIDER}"
  if call_provider "$fn"; then return 0; fi
  printf 'Provider '\''%s'\'' does not provide %s().\n' "$PROVIDER" "$fn" >&2
  exit "$GROQBASHERRAPI"
}

call_api_once() {
  if [ "${DRY_RUN:-0}" -eq 1 ]; then
    show_payload_head "$PAYLOAD" 200 || true
    printf 'DRY-RUN: skipping provider HTTP call (exit 0)\n' >&2
    return 0
  fi
  local fn="callapi${PROVIDER}"
  if call_provider "$fn"; then return 0; fi
  printf 'Provider '\''%s'\'' does not provide %s().\n' "$PROVIDER" "$fn" >&2
  exit "$GROQBASHERRAPI"
}

call_api_streaming() {
  if [ "${DRY_RUN:-0}" -eq 1 ]; then
    show_payload_head "$PAYLOAD" 200 || true
    printf 'DRY-RUN: skipping provider streaming HTTP call (exit 0)\n' >&2
    return 0
  fi
  local fn="callapistreaming_${PROVIDER}"
  if call_provider "$fn"; then return 0; fi
  printf 'Provider '\''%s'\'' does not provide %s().\n' "$PROVIDER" "$fn" >&2
  exit "$GROQBASHERRAPI"
}

show_payload_head() {
  local path="${1:-$PAYLOAD}" lines="${2:-200}"
  if [ -z "${path:-}" ]; then
    printf 'DRY-RUN: payload file missing: %s\n' "<unset>" >&2
    exit "$GROQBASHERRTMP"
  fi
  if [ ! -e "$path" ]; then
    printf 'DRY-RUN: payload file missing: %s\n' "$path" >&2
    exit "$GROQBASHERRTMP"
  fi
  if [ ! -s "$path" ]; then
    printf 'DRY-RUN: payload exists but is empty: %s\n' "$path" >&2
    return 0
  fi
  printf 'DRY-RUN: payload path: %s\n' "$path" >&2
  printf 'DRY-RUN: payload (head %d lines):\n' "$lines" >&2
  head -n "$lines" "$path" 2>/dev/null >&2 || true
  return 0
}

extract_text_from_resp() {
  [ ! -s "$RESP" ] && return 0
  jq -r '
    ( .choices[]?.message?.content // .choices[]?.delta?.content // empty ) | select(length>0)
  ' "$RESP" 2>/dev/null | sed 's/\\n/\n/g' | sed 's/\\"/"/g' | head -n 1 || true
  return 0
}

extract_api_error() {
  [ ! -s "$RESP" ] && return 0
  jq -r '.error?.message // .choices[]?.message?.content // empty' "$RESP" 2>/dev/null | head -n1 || true
}

finalize_and_output() {
  local mode="$1" text="$2"
  case "$mode" in
    json) cat "$RESP" ;;
    pretty) sed 's/{/{\n/g; s/}/\n}/g; s/,/,\n/g' "$RESP" || cat "$RESP" ;;
    raw) printf '%s' "$text" ;;
    text) printf '%s\n' "$text" ;;
    *) printf '%s\n' "$text" ;;
  esac

  if [ "$mode" = "text" ] || [ "$mode" = "raw" ]; then
    [ "${FORCE_SAVE_MODE:-}" = "nosave" ] && return 0
    local len do_save=0 tmpf dest_dir dest_path
    len="$(printf '%s' "$text" | wc -c | tr -d ' ')"
    if [ "${FORCE_SAVE_MODE:-}" = "save" ]; then
      do_save=1
    else
      if [ "$len" -gt "$THRESHOLD" ]; then
        do_save=1
      fi
    fi
    if [ "$do_save" -eq 1 ]; then
      if [ -n "$OUT_PATH" ]; then
        if [ -d "$OUT_PATH" ]; then dest_dir="$OUT_PATH"; dest_path="$dest_dir/$(date +%Y%m%d-%H%M%S)-groq-output-$$.txt"; else dest_path="$OUT_PATH"; dest_dir="$(dirname "$dest_path")"; fi
      else dest_dir="$GROQBASH_HISTORY_DIR"; dest_path="$dest_dir/$(date +%Y%m%d-%H%M%S)-groq-output-$$.txt"; fi
      mkdir -p "$dest_dir" 2>/dev/null || true
      tmpf="$(mktemp -p "$RUN_TMPDIR" groq-out.XXXX 2>/dev/null || true)"
      [ -z "$tmpf" ] && { printf 'Error: cannot create temporary file for saving. Skipping save.\n' >&2; exit "$GROQBASHERRTMP"; }
      printf '%s\n' "$text" > "$tmpf"
      if mv "$tmpf" "$dest_path" 2>/dev/null; then chmod 600 "$dest_path" 2>/dev/null || true; printf 'Output saved to: %s\n' "$dest_path" >&2; else printf 'Output saved to (tmp): %s\n' "$tmpf" >&2; fi
    fi
  fi
}

perform_request_once() {
  local attempt=1 rc
  while [ "$attempt" -le "$MAX_RETRIES" ]; do
    if call_api_once; then
      if [ "${DRY_RUN:-0}" -eq 1 ]; then
        printf 'DRY-RUN: request simulated successfully. Payload: %s\n' "$PAYLOAD" >&2
        return 0
      fi
      local text api_err
      text="$(extract_text_from_resp || true)"
      if [ -z "$text" ] && [ "$OUTPUT_MODE" != "json" ] && [ "$OUTPUT_MODE" != "pretty" ]; then
        api_err="$(extract_api_error || true)"
        if [ -n "$api_err" ]; then
          printf 'API error: %s\n' "$api_err" >&2
          return "$GROQBASHERRAPI"
        else
          printf 'Error: no textual content extracted from response.\n' >&2
          dbg "RESP (head):"; head -n 50 "$RESP" >&2 || true
          return "$GROQBASHERRAPI"
        fi
      fi
      finalize_and_output "$OUTPUT_MODE" "$text"
      return 0
    else
      rc=$?
      if [ "$rc" -eq "$GROQBASHERRCURL_FAILED" ]; then printf 'Network error (curl). Retrying...\n' >&2
      elif [ "$rc" -eq "$GROQBASHERRAPI" ]; then printf 'HTTP/API error. Not retrying.\n' >&2; dbg "RESP (head):"; head -n 50 "$RESP" >&2 || true; return "$GROQBASHERRAPI"
      else printf 'Unknown error (code %s). Retrying...\n' "$rc" >&2
      fi
    fi
    attempt=$((attempt + 1)); sleep $((attempt * 1))
  done
  printf 'Error: request failed after %s attempts.\n' "$MAX_RETRIES" >&2
  return "$GROQBASHERRAPI"
}

collect_input_from_files() {
  local out="" first=1 f
  for f in "$@"; do
    if file_readable "$f"; then
      [ "$first" -eq 0 ] && out="${out}"$'\n\n'"--- FILE: ${f} ---"$'\n\n'
      out="${out}$(cat "$f")"; first=0
    else printf 'Error: file not readable: %s\n' "$f" >&2; exit "$GROQBASHERRTMP"; fi
  done
  printf '%s' "$out"
}
expand_args_to_content() {
  local out="" first=1 a
  for a in "${ARGS[@]}"; do
    if file_readable "$a"; then
      [ "$first" -eq 0 ] && out="${out}"$'\n\n'"--- FILE: ${a} ---"$'\n\n'
      out="${out}$(cat "$a")"; first=0
    else
      [ "$first" -eq 0 ] && out="${out}"$'\n\n'
      out="${out}${a}"; first=0
    fi
  done
  printf '%s' "$out"
}

# CLI parsing
JSON_INPUT="" TEMPLATE="" BATCH_FILE="" CHAT_MODE=0 SET_DEFAULT_MODEL=""
REFRESH_MODELS=0 LIST_MODELS=0 FORCE_SAVE_MODE="" OUT_PATH=""

while [ $# -gt 0 ]; do
  case "$1" in
    --refresh-models|--refresh-model) REFRESH_MODELS=1; shift ;;
    --list-models) LIST_MODELS=1; shift ;;
    --set-default) SET_DEFAULT_MODEL="${2:-}"; shift 2 ;;
    -m|--model) MODEL="${2:-}"; shift 2 ;;
    -f) FILE_INPUTS+=("${2:-}"); shift 2 ;;
    --json-input) JSON_INPUT="${2:-}"; shift 2 ;;
    --template) TEMPLATE="${2:-}"; shift 2 ;;
    --batch) BATCH_FILE="${2:-}"; shift 2 ;;
    --system) SYSTEM_PROMPT="${2:-}"; shift 2 ;;
    --ture) TURE="${2:-}"; shift 2 ;;
    --max) MAX_TOKENS="${2:-}"; shift 2 ;;
    --debug) DEBUG=1; shift ;;
    --save) FORCE_SAVE_MODE="save"; shift ;;
    --nosave) FORCE_SAVE_MODE="nosave"; shift ;;
    --out) OUT_PATH="${2:-}"; shift 2 ;;
    --threshold) THRESHOLD="${2:-}"; shift 2 ;;
    --dry-run) DRY_RUN=1; shift ;;
    --quiet) QUIET=1; shift ;;
    --stream) STREAM_MODE="true"; shift ;;
    --no-stream) STREAM_MODE="false"; shift ;;
    --json) OUTPUT_MODE="json"; shift ;;
    --pretty) OUTPUT_MODE="pretty"; shift ;;
    --text) OUTPUT_MODE="text"; shift ;;
    --raw) OUTPUT_MODE="raw"; shift ;;
    --chat) CHAT_MODE=1; shift ;;
    --provider)
      if [ "${2:-}" ] && [ "${2:0:1}" != "-" ]; then PROVIDER_CLI="${2:-}"; shift 2; else PROVIDER_INTERACTIVE=1; shift; fi
      ;;
    --install-extras)
      INSTALL_EXTRAS=1; shift ;;
    --version) printf '%s %s (%s)\n' "$SCRIPT_NAME" "$SCRIPT_VERSION" "$SCRIPT_DATE"; exit 0 ;;
    -h|--help)
      help_file="$GROQBASH_EXTRAS_DIR/docs/help.txt"
      if [ -f "$help_file" ]; then
        cat "$help_file"
      else
        printf 'Help file not found: %s\n' "$help_file" >&2
      fi
      exit 0
      ;;
    --) shift; break ;;
    -*)
      printf 'Unknown option: %s\n' "$1" >&2
      exit "$GROQBASHERRTMP"
      ;;
    *)
      ARGS+=("$1")
      shift
      ;;
  esac
done

# Handle immediate CLI actions that don't require a prompt
if [ "${REFRESH_MODELS:-0}" -eq 1 ]; then
  refresh_models_dispatch "$MODELS_FILE" || exit "$GROQBASHERRAPI"
  exit 0
fi

if [ "${LIST_MODELS:-0}" -eq 1 ]; then
  if [ -f "$MODELS_FILE" ] && [ -s "$MODELS_FILE" ]; then
    cat "$MODELS_FILE" >&2
    exit 0
  else
    printf 'No models available locally. Consider --refresh-models.\n' >&2
    exit "$GROQBASHERRTMP"
  fi
fi

if [ -n "${SET_DEFAULT_MODEL:-}" ]; then
  mkdir -p "$GROQBASH_CONFIG_DIR" 2>/dev/null || true
  printf '%s\n' "$SET_DEFAULT_MODEL" > "$GROQBASH_CONFIG_DIR/model.$PROVIDER" 2>/dev/null || { printf 'Error: cannot write default model.\n' >&2; exit "$GROQBASHERRTMP"; }
  chmod 600 "$GROQBASH_CONFIG_DIR/model.$PROVIDER" 2>/dev/null || true
  printf 'Default model for provider %s set to: %s\n' "$PROVIDER" "$SET_DEFAULT_MODEL" >&2
  exit 0
fi

if [ "${STREAM_MODE:-}" = "true" ] && { [ "$OUTPUT_MODE" = "json" ] || [ "$OUTPUT_MODE" = "pretty" ]; }; then
  printf 'Error: --stream is not compatible with --json/--pretty (streaming produces partial JSON). Use --text or --raw for streaming.\n' >&2
  exit "$GROQBASHERRTMP"
fi

if [ "$INSTALL_EXTRAS" -eq 1 ]; then
  dest_base="$GROQBASH_EXTRAS_DIR"
  dest_docs="$dest_base/docs"
  dest_lib="$dest_base/lib"
  dest_prov="$dest_base/providers"
  src_base="$SCRIPTDIR/extras"
  src_docs="$src_base/docs/core-notes.sh"
  src_utils="$src_base/lib/utils.sh"
  src_debug="$src_base/lib/debug.sh"
  src_groq="$src_base/providers/groq.sh"
  if ! mkdir -p "$dest_docs" "$dest_lib" "$dest_prov" 2>/dev/null; then
    printf 'Error: cannot create extras directories under %s\n' "$dest_base" >&2
    exit "$GROQBASHERRTMP"
  fi
  for src in "$src_docs" "$src_utils" "$src_debug" "$src_groq"; do
    if [ ! -f "$src" ]; then
      printf 'Error: bundled extras file not found: %s\n' "$src" >&2
      exit "$GROQBASHERRTMP"
    fi
  done
  cp -f "$src_docs" "$dest_docs/" || { printf 'Error copying extras\n' >&2; exit "$GROQBASHERRTMP"; }
  cp -f "$src_utils" "$dest_lib/" || { printf 'Error copying extras\n' >&2; exit "$GROQBASHERRTMP"; }
  cp -f "$src_debug" "$dest_lib/" || { printf 'Error copying extras\n' >&2; exit "$GROQBASHERRTMP"; }
  cp -f "$src_groq" "$dest_prov/" || { printf 'Error copying extras\n' >&2; exit "$GROQBASHERRTMP"; }
  chmod 644 "$dest_docs/core-notes.sh" 2>/dev/null || true
  chmod 644 "$dest_lib/utils.sh" 2>/dev/null || true
  chmod 644 "$dest_lib/debug.sh" 2>/dev/null || true
  chmod 644 "$dest_prov/groq.sh" 2>/dev/null || true
  printf 'Extras installed under %s/extras/\n' "$GROQBASH_DIR" >&2
  exit 0
fi

load_local_config
load_whitelist

PROVIDER_FILE="$GROQBASH_CONFIG_DIR/provider"
if [ -f "$PROVIDER_FILE" ] && [ -z "${PROVIDER_CLI:-}" ] && [ "$PROVIDER_INTERACTIVE" -eq 0 ]; then
  prov="$(sed -n '1p' "$PROVIDER_FILE" 2>/dev/null || true)"; [ -n "$prov" ] && PROVIDER="$prov"
fi
if [ -n "${PROVIDER_CLI:-}" ] && [ "${PROVIDER_CLI}" != "list" ]; then
  PROVIDER="$PROVIDER_CLI"; printf '%s\n' "$PROVIDER" > "$PROVIDER_FILE"; chmod 600 "$PROVIDER_FILE" 2>/dev/null || true
  refresh_models_dispatch "$MODELS_FILE" || true
fi

if [ "$PROVIDER_INTERACTIVE" -eq 1 ] || [ "${PROVIDER_CLI:-}" = "list" ]; then
  IFS=' ' read -r -a _prov_arr <<EOF
$SUPPORTED_PROVIDERS
EOF
  current_default="$PROVIDER"
  [ -f "$PROVIDER_FILE" ] && pf="$(sed -n '1p' "$PROVIDER_FILE" 2>/dev/null || true)" && [ -n "$pf" ] && current_default="$pf"
  printf 'Select provider:\n' >&2
  i=1
  for p in "${_prov_arr[@]}"; do
    if [ "$p" = "$current_default" ]; then printf '%d) %s (default)\n' "$i" "$p" >&2; else printf '%d) %s\n' "$i" "$p" >&2; fi
    i=$((i+1))
  done
  printf '> ' >&2
  if ! IFS= read -r sel; then printf 'No selection made. Exiting.\n' >&2; exit "$GROQBASHERRTMP"; fi
  sel="$(trim "$sel")"
  if ! printf '%s\n' "$sel" | grep -qE '^[0-9]+$'; then printf 'Invalid selection. Exiting.\n' >&2; exit "$GROQBASHERRTMP"; fi
  idx="$sel"; chosen="${_prov_arr[$((idx-1))]}"
  [ -z "$chosen" ] && { printf 'Selection out of range. Exiting.\n' >&2; exit "$GROQBASHERRTMP"; }
  printf '%s\n' "$chosen" > "$PROVIDER_FILE"; chmod 600 "$PROVIDER_FILE" 2>/dev/null || true; PROVIDER="$chosen"
  refresh_models_dispatch "$MODELS_FILE" || true
  exit 0
fi

refresh_models_dispatch() {
  local outpath="${1:-$MODELS_FILE}"
  local fn="refreshmodels${PROVIDER}"
  if type "$fn" >/dev/null 2>&1; then "$fn" "$outpath"; return $?; fi
  printf 'Provider '\''%s'\'' does not support model refresh.\n' "$PROVIDER" >&2
  exit "$GROQBASHERRAPI"
}
validate_model_dispatch() {
  local model="$1"
  local fn="validatemodel${PROVIDER}"
  if type "$fn" >/dev/null 2>&1; then "$fn" "$model"; return $?; fi
  if [ -n "$ALLOWED_MODELS" ]; then
    printf '%s\n' "$ALLOWED_MODELS" | grep -x -F -q "$model"
    return $?
  fi
  return 0
}
auto_select_model_dispatch() {
  local fn="autoselectmodel${PROVIDER}"
  if type "$fn" >/dev/null 2>&1; then "$fn"; return 0; fi
  if [ -f "$MODELS_FILE" ] && [ -s "$MODELS_FILE" ]; then
    if jq -e . "$MODELS_FILE" >/dev/null 2>&1; then
      jq -r '.data[]?.id // empty' "$MODELS_FILE" 2>/dev/null | awk 'NF{print; exit}' || printf ''
    else
      awk 'NF{print; exit}' "$MODELS_FILE" 2>/dev/null || printf ''
    fi
    return 0
  fi
  printf ''
  return 0
}

MODEL_PROVIDER_CFG="$GROQBASH_CONFIG_DIR/model.$PROVIDER"
if [ -z "${MODEL:-}" ] && [ -f "$MODEL_PROVIDER_CFG" ] && [ -s "$MODEL_PROVIDER_CFG" ]; then
  cand="$(sed -n '1p' "$MODEL_PROVIDER_CFG" 2>/dev/null || true)"; [ -n "$cand" ] && MODEL="$cand"
fi

if [ -z "${MODEL:-}" ]; then
  cand="$(auto_select_model_dispatch 2>/dev/null || true)"
  [ -n "$cand" ] && MODEL="$cand"
fi

if [ -z "$MODEL" ] && [ -f "$GROQBASH_CONFIG_DIR/config" ]; then
  cand="$(awk -F= '/^MODEL=/ {sub(/^MODEL=/,""); print $0; exit}' "$GROQBASH_CONFIG_DIR/config" 2>/dev/null || true)"
  [ -n "$cand" ] && MODEL="$cand"
fi
[ -z "$MODEL" ] && [ -n "$ALLOWED_MODELS" ] && MODEL="$(awk 'NF{print; exit}' <<<"$ALLOWED_MODELS" 2>/dev/null || printf '')"

if [ -n "$MODEL" ]; then
  if ! validate_model_dispatch "$MODEL"; then
    printf 'Error: model '\''%s'\'' not supported or deprecated.\n' "$MODEL" >&2
    if [ -n "$ALLOWED_MODELS" ]; then
      printf 'Available models (local whitelist):\n' >&2
      printf '%s\n' "$ALLOWED_MODELS" >&2
    fi
    exit "$GROQBASHERRBAD_MODEL"
  fi
fi

PROVIDER_MODULE_LOADED=0
provider_module_path="$GROQBASH_EXTRAS_DIR/providers/${PROVIDER}.sh"
provider_dir="$(dirname "$provider_module_path")"

if [ ! -d "$provider_dir" ]; then
  if ! mkdir -p "$provider_dir" 2>/dev/null; then
    printf 'Error: cannot create provider directory: %s\n' "$provider_dir" >&2
    exit "$GROQBASHERRTMP"
  fi
fi
if _is_world_writable "$provider_dir"; then
  printf 'Security error: extras/providers directory is world-writable; refusing to load provider modules.\n' >&2
  exit "$GROQBASHERRTMP"
fi
current_user="$(id -un 2>/dev/null || printf '')"
owner="$(_get_owner "$provider_dir")"
if [ -n "$owner" ] && [ -n "$current_user" ] && [ "$owner" != "$current_user" ]; then
  dbg "Warning: provider directory $provider_dir is owned by $owner, not $current_user."
fi
providerfile="$provider_module_path"
beforesig="$(getfile_signature "$providerfile")"
if [ ! -f "$providerfile" ]; then
  if [ "$PROVIDER" != "groq" ]; then
    printf 'Provider '\''%s'\'' is not installed. Run --install-extras or provide a valid provider plugin.\n' "$PROVIDER" >&2
    PROVIDER_MODULE_LOADED=0
  else
    PROVIDER_MODULE_LOADED=1
  fi
else
  file_owner="$(_get_owner "$providerfile")"
  current_user="${USER:-$(id -un 2>/dev/null || printf '')}"
  if [ -n "$file_owner" ] && [ -n "$current_user" ] && [ "$file_owner" != "$current_user" ]; then
    printf 'Security error: provider file not owned by current user: %s\n' "$providerfile" >&2
    exit "$GROQBASHERRTMP"
  fi
  perms="$(_get_perm_string "$providerfile")"
  group_write="$(printf '%s' "$perms" | awk '{print substr($0,6,1)}')"
  others_write="$(printf '%s' "$perms" | awk '{print substr($0,9,1)}')"
  if [ "$group_write" = "w" ] || [ "$others_write" = "w" ]; then
    printf 'Security error: provider file is writable by group or world: %s\n' "$providerfile" >&2
    exit "$GROQBASHERRTMP"
  fi
  if [ -L "$providerfile" ]; then
    printf 'Security error: provider file is a symlink: %s\n' "$providerfile" >&2
    exit "$GROQBASHERRTMP"
  fi
  aftersig="$(getfile_signature "$providerfile")"
  if [ "$beforesig" != "$aftersig" ]; then
    printf 'Security error: provider file changed during validation: %s\n' "$providerfile" >&2
    exit "$GROQBASHERRTMP"
  fi
  # shellcheck source=/dev/null
  . "$provider_module_path"
  PROVIDER_MODULE_LOADED=1
fi

validate_provider_interface() {
  local p="$1" missing=0
  local funcs=( "buildpayload${p}" "callapi${p}" "callapistreaming_${p}" "refreshmodels${p}" "validatemodel${p}" "autoselectmodel${p}" )
  local f
  for f in "${funcs[@]}"; do
    if ! type "$f" >/dev/null 2>&1; then
      printf 'Provider '\''%s'\'' module does not define %s().\n' "$p" "$f" >&2
      missing=1
    fi
  done
  return $missing
}

if [ "$PROVIDER_MODULE_LOADED" -eq 1 ]; then
  validate_provider_interface "$PROVIDER" || exit "$GROQBASHERRAPI"
else
  printf 'Error: no valid provider loaded for '\''%s'\''. Install or configure a provider plugin.\n' "$PROVIDER" >&2
  exit "$GROQBASHERRAPI"
fi

[ -n "$BATCH_FILE" ] && [ ! -r "$BATCH_FILE" ] && { printf 'Error: batch file not readable: %s\n' "$BATCH_FILE" >&2; exit "$GROQBASHERRTMP"; }
if [ -n "$JSON_INPUT" ]; then
  [ ! -r "$JSON_INPUT" ] && { printf 'Error: JSON input file not readable: %s\n' "$JSON_INPUT" >&2; exit "$GROQBASHERRINVALID_JSON"; }
  if ! jq -e . "$JSON_INPUT" >/dev/null 2>&1; then
    printf 'Error: JSON input is not valid JSON.\n' >&2
    exit "$GROQBASHERRINVALID_JSON"
  fi
fi
[ -n "$TEMPLATE" ] && [ ! -f "$GROQBASH_TEMPLATES_DIR/$TEMPLATE" ] && { printf 'Error: template not found: %s\n' "$TEMPLATE" >&2; exit "$GROQBASHERRTMP"; }

STDIN_CONTENT=""; [ ! -t 0 ] && STDIN_CONTENT="$(cat - 2>/dev/null || true)"
CONTENT="${CONTENT:-}"

if [ -n "$JSON_INPUT" ]; then :; else
  if [ "${#FILE_INPUTS[@]}" -gt 0 ]; then
    CONTENT="$(collect_input_from_files "${FILE_INPUTS[@]}")"
    [ "${#ARGS[@]}" -gt 0 ] && extra="$(expand_args_to_content)" && [ -n "$extra" ] && CONTENT="${CONTENT}"$'\n\n'"$extra"
  elif [ -n "$TEMPLATE" ]; then
    if [ "${#FILE_INPUTS[@]}" -gt 0 ]; then CONTENT="$(collect_input_from_files "${FILE_INPUTS[@]}")"
    elif [ -n "$STDIN_CONTENT" ]; then CONTENT="$STDIN_CONTENT"
    else [ "${#ARGS[@]}" -gt 0 ] && CONTENT="$(expand_args_to_content)" || CONTENT=""
    fi
    tmpl="$(cat "$GROQBASH_TEMPLATES_DIR/$TEMPLATE")"
    tmp_tmpl="$(mktemp -p "$GROQBASH_TMPDIR" groq-tmpl.XXXX 2>/dev/null || true)"
    if [ -n "$tmp_tmpl" ]; then
      printf '%s' "$tmpl" | awk -v repl="$CONTENT" 'BEGIN{RS=""; ORS="";} {gsub(/\{\{CONTENT\}\}/, repl); print}' > "$tmp_tmpl"
      mv "$tmp_tmpl" "$tmp_tmpl.final" 2>/dev/null || true
      CONTENT="$(cat "$tmp_tmpl.final" 2>/dev/null || printf '%s' "$tmpl")"
      rm -f "$tmp_tmpl" "$tmp_tmpl.final" 2>/dev/null || true
    else
      CONTENT="$(printf '%s' "$tmpl" | awk -v repl="$CONTENT" 'BEGIN{RS=""; ORS="";} {gsub(/\{\{CONTENT\}\}/, repl); print}' )"
    fi
  elif [ -n "$STDIN_CONTENT" ]; then
    CONTENT="$STDIN_CONTENT"
    [ "${#ARGS[@]}" -gt 0 ] && extra="$(expand_args_to_content)" && [ -n "$extra" ] && CONTENT="${CONTENT}"$'\n\n'"$extra"
  else
    [ "${#ARGS[@]}" -gt 0 ] && CONTENT="$(expand_args_to_content)" || CONTENT=""
  fi
fi

if [ -z "$CONTENT" ] && [ -z "$JSON_INPUT" ] && [ "$CHAT_MODE" -eq 0 ] && [ -z "$BATCH_FILE" ]; then
  printf 'Error: no prompt provided.\n' >&2
  exit "$GROQBASHERRNO_PROMPT"
fi

is_number "$TURE" || { printf 'Error: --ture must be numeric\n' >&2; exit "$GROQBASHERRTMP"; }
is_number "$MAX_TOKENS" || { printf 'Error: --max must be numeric\n' >&2; exit "$GROQBASHERRTMP"; }

if [ -n "$ALLOWED_MODELS" ] && [ -n "$MODEL" ]; then
  if ! printf '%s\n' "$ALLOWED_MODELS" | grep -x -F -q "$MODEL"; then
    printf 'Error: model '\''%s'\'' not supported or deprecated.\n' "$MODEL" >&2
    printf 'Available models (local whitelist):\n' >&2
    printf '%s\n' "$ALLOWED_MODELS" >&2
    exit "$GROQBASHERRBAD_MODEL"
  fi
fi

ensure_run_tmpdir

if [ -n "$BATCH_FILE" ]; then
  while IFS= read -r line || [ -n "$line" ]; do
    case "$line" in ''|\#*) continue ;; esac
    CONTENT="$line"
    build_payload_from_vars
    if [ "${STREAM_MODE:-}" = "true" ]; then call_api_streaming || { printf 'Error during streaming call.\n' >&2; continue; }; else perform_request_once || true; fi
    printf '\n----\n'
  done < "$BATCH_FILE"
  exit 0
fi

if [ "$CHAT_MODE" -eq 1 ]; then
  if [ ! -t 0 ]; then printf 'Error: interactive chat requires a TTY.\n' >&2; exit "$GROQBASHERRTMP"; fi
  [ -t 1 ] && [ "$QUIET" -ne 1 ] && { printf 'Entering interactive chat. Press Ctrl+D to exit.\n' >&2; } || printf 'Entering interactive chat. Press Ctrl+D to exit.\n' >&2
  CONVERSATION=""
  while true; do
    if is_tty_out && [ "$QUIET" -ne 1 ] && { [ "$OUTPUT_MODE" = "text" ] || [ "$OUTPUT_MODE" = "raw" ]; }; then printf '\nYou: ' >&2; fi
    if ! IFS= read -r userline; then printf '\n' >&2; break; fi
    [ -z "$userline" ] && continue
    [ -z "$CONVERSATION" ] && CONVERSATION="$userline" || CONVERSATION="${CONVERSATION}"$'\n\n'"User: ${userline}"
    CONTENT="$userline"
    build_payload_from_vars
    if [ "${STREAM_MODE:-}" = "true" ]; then call_api_streaming || printf 'Streaming call failed.\n' >&2; else perform_request_once || printf 'Call failed.\n' >&2; fi
  done
  exit 0
fi

if [ "${STREAM_MODE:-}" = "true" ]; then
  build_payload_from_vars
  if call_api_streaming; then dbg "Streaming completed; captured response in $RESP"; printf '\n'; exit 0; else printf 'Error: streaming request failed.\n' >&2; exit "$GROQBASHERRCURL_FAILED"; fi
else
  if is_tty_out && [ "$QUIET" -ne 1 ] && { [ "$OUTPUT_MODE" = "text" ] || [ "$OUTPUT_MODE" = "raw" ]; }; then
    printf '%b\n' "\033[1;36mYou:\033[0m" >&2
    if [ "${#ARGS[@]}" -gt 0 ]; then
      anyfile=0
      for a in "${ARGS[@]}"; do [ -r "$a" ] && [ -f "$a" ] && { anyfile=1; break; }; done
      [ "$anyfile" -eq 1 ] && printf '%s\n' "(using file contents)" >&2 || printf '%s\n' "$CONTENT" >&2
    else printf '%s\n' "$CONTENT" >&2; fi
    printf '%b\n' "\033[1;32mProvider ($PROVIDER, model: $MODEL):\033[0m" >&2
  fi
  build_payload_from_vars
  perform_request_once || exit "$GROQBASHERRAPI"
  exit 0
fi

# End of file
